# Loop 6 IPC 핸들러 camelCase 변환 및 새로고침 문제 해결

## 날짜: 2025년 6월 11일

## 현재 상황

### ✅ 해결된 문제들
1. **중복 IPC 핸들러 등록 오류**: 안전한 핸들러 등록 시스템으로 해결
2. **메인 윈도우 생성**: 실무적인 3단계 초기화 패턴으로 성공적으로 해결
3. **네이티브 모듈 로드**: 37개 함수, 27개 핸들러 정상 등록

### 🔄 진행 중인 작업
**camelCase 통일 작업**: kebab-case에서 camelCase로 변환

#### 변환 완료된 IPC 채널들
- `memory:get-info` → `memory:getInfo`
- `gpu:get-info` → `gpu:getInfo`
- `system:native:get-status` → `system:native:getStatus`

### ❌ 현재 발생 중인 문제들

#### 1. IPC 핸들러 이름 불일치 오류
```
memory:getInfo 핸들러가 이미 등록되어 있어서 건너뜀: Error: Attempted to register a second handler for 'memory:getInfo'
```

**원인 분석**:
- preload.ts에서 채널명을 camelCase로 변경했지만
- main.ts의 일부 핸들러는 아직 kebab-case를 사용
- 이로 인해 새로운 camelCase 핸들러와 기존 kebab-case 핸들러가 충돌

#### 2. 지속적인 페이지 새로고침 문제
```
info: ⏹️ 페이지 로드 중단 {"timestamp":"2025-06-11 08:41:19"}
info: 🔄 페이지 로드 시작 {"timestamp":"2025-06-11 08:41:19"}
info: ⏳ 페이지 로드 시작 {"timestamp":"2025-06-11 08:41:19"}
info: ⏹️ 페이지 로드 중단 {"timestamp":"2025-06-11 08:41:19"}
```

**원인 분석**:
- CSP 헤더 후킹이 여러 번 실행되어 페이지 재로드 발생
- 로드 이벤트 리스너가 중복 등록되어 무한 루프 발생 가능성

## 해결 계획

### Phase 1: IPC 핸들러 이름 통일
1. main.ts의 모든 kebab-case 핸들러를 camelCase로 변환
2. memory-ipc.ts, system-info-ipc.ts 등의 파일에서 일관성 확보
3. 중복 등록 방지 로직 강화

### Phase 2: 새로고침 문제 해결
1. window.ts의 로드 이벤트 리스너 중복 제거
2. CSP 헤더 후킹 최적화
3. 로드 상태 추적 개선

### Phase 3: 통합 테스트
1. 모든 IPC 채널 정상 작동 확인
2. 네이티브 모듈 API 테스트
3. UI 안정성 검증

## 작업 우선순위
1. **HIGH**: IPC 핸들러 이름 통일 (기능 복구)
2. **HIGH**: 새로고침 문제 해결 (사용성 개선)
3. **MEDIUM**: 코드 정리 및 최적화

## 다음 단계
- main.ts의 essential IPC 핸들러들을 camelCase로 변환
- memory-ipc.ts와 system-info-ipc.ts의 모든 채널명 통일
- window.ts의 로드 이벤트 최적화
